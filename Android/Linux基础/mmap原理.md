##### 内存映射种类

* 私有映射：内存段为调用进程所私有。对该内存段的修改不会反映到映射文件，这个过程有写时复制机制，比如A进程与设备建立了mmap，进行了映射，B进程不会分配自己的线性空间，指向A进程的线性空间，当B进程修改了映射的内容后，重新会给B进程分配自己独立的线性空间。

* 共享型内存映射：进程间共享内存，对该内存段修改反映到映射文件中

  总结：

  mmap分为有后备文件的映射和匿名文件的映射，这两种映射又有私有映射和共享映射之分，所以mmap可以创建4种类型的映射

  1. 后备文件的共享映射，多个进程的vm_area_struct指向同一个物理内存区域，一个进程对文件内容的修改，会被其他进程可见。对文件内容的修改会被写回到后备文件。
  2. 后备文件的私有映射，多个进程的vm_area_struct指向同一个物理内存区域，采用写时拷贝的方式，当一个进程对文件内容做修改，不会被其他进程看到。另外对文件内的修改也不会被写回到后备文件。当内存不够需要进行页回收时，私有映射的页被交换到交换区。一般用在加载共享代码库
  3. 匿名文件的共享映射，内核创建一个初始都是0的物理内存区域，然后多个进程的vm_area_struct指向这个共享的物理内存区域，对该区域内容的修改对所有进程可见。匿名文件在页回收时被交换到交换区
  4. 匿名文件的私有映射，内核创建一个初始都是0的物理内存区域，对该区域内容的修改只对创建者进程可见。匿名文件在页回收时被交换到交换区。malloc()底层是用了匿名文件的私有映射来分配大块内存。

  内存映射的用途很多，比如

  1. 后备文件的共享映射可以用作内存映射IO来对大文件进行操作，比普通IO减少一次复制。需要注意的是内存映射IO涉及到内核的很多操作，比如vm_area_struct的创建，页表的修改等等，比普通IO的操作更复杂。小文件的读写使用普通IO更合适
  2. 后备文件的私有映射可以用作共享库二进制文件代码段，数据段的加载
  3. 匿名文件的共享映射可以用作fork时让父子进程共享匿名映射分配的内存
  4. 匿名文件的私有映射可以用作进程的私有内存分配

  ##### mmap基本原理

* 进程的虚拟地址线性区和磁盘块设备文件关联，达到线性区某页的访问，转换成对块设备的字节操作。

* 和传统读写比较，传统RW需要先进入内核态使用页缓存机制和页中断机制，通过块设备数据复制到页缓存（内核缓存），再从页缓存到用户态物理内存缓存，两次复制；而mmap通过进程调用mmap函数（当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址）和内核调用mmap建立映射后，通过异常中断，只会从块设备复制一次数据到主存，而这个主存有映射关系的所有进程都可以访问，跳过了页缓存机制（页缓存到用户空间），少了内核复制到用户态的复制过程。所以已经建立好映射的进程访问已经复制到主存的映射数据，一次拷贝都不需要。

### 注意

* 进程崩溃时，mmap的内存内核是会帮你写回到磁盘的
* 映射建立之后，即使文件关闭，映射依然存在。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。同时可用于进程间通信的有效地址空间不完全受限于被映射文件的大小，因为是按页映射。

