### mmap在android日志写入本地文件的应用

#### 应用要求

* log.i(tag,"")调用
* debug模式下，允许调试终端查看日志信息，通过Android原生查看
* 不频繁打开文件、写入文件
    * 直接调用文件IO，至少要创建文件写入流对象，要打开文件写入，两次拷贝，不会丢失数据
    * 如果使用零时缓存，程序意外结束可能不会将缓存写入，会丢失数据
    * 使用mmap先打开200k的文件，映射200K的主存，映射好之后，不关心主存何时落盘到文件（实际也无法印证，mmap映射一段主存后，通过memcpy函数或者直接将指写入char *c中，也无法知道系统何时落盘，太透明了），不会丢失数据
* 支持多线程日志打印
* Android使用worker上传日志
* Android使用崩溃捕获类捕获崩库数据，处理完成后，程序自行结束（一般自行结束，执行不到后面的代码），或者主动结束

###### 性能测试
CPU性能

 * 写入几个字符1W次，mmap映射5M的时候，花费的CPU时间大概是普通文件写入的1/2不到，CPU占用大概为15%，时间大概800ms
 * 分析1--普通终端：用户很难有1w次的日志写入机会，所以mmap用来写日志就是个噱头，这个不像用于服务器，服务器方面，有高并发场景下，不管是写日志或者类似于服务器的消息队列的场景，比如消息推送可能会用RabbitMQ，这些服务器的场景并发高，IO频繁，甚至只有服务器主存到socketIO的场景，不会经过文件，可以用mmap实现零拷贝，那么mmap就是非常有用的，在Android或者IOS个人终端下，几乎没有并发，也写不到一万次甚至1000次，为什么要维护一套mmap的日志框架？催毛求疵？
 * 分析2--系统开发：某team说 利用mmap可以解决100w次的性能问题，甚至有性能截图（100w次写入耗费200多毫秒，我太怀疑了，mmap始终也会触发脏页写入最终文件的，除非不是共享设备映射，但是不共享怎么最终落盘呢），目的其一是防止卡顿，我想，懂Android的都应该明白，日志是打印不到100万次的，谁会要求在短时间打印100w次？ROM开发，记录整个系统的日志基础服务打印的日志可能多，但是这个是在终端跑了N个进程的前提下，没有必要让这个日志基础服务作为一个单独进程，其他进程通过binder来打印日志，这个怕得不偿失吧？单独的进程单独日志记录不就好了吗？（如果真的像adb一样，可以直接汇总日志，那mmap就有Android的日志应用场景）
 * 分析3--看待卡顿：app卡顿时，罪魁祸首会是log吗？或者说快要卡顿的时候，打印日志就会导致卡顿吗？Android的卡顿应该不在打印几行log上，而是加载图片，资源什么的，或者绘制了复杂的界面，这种大型消耗CPU资源、占用内存、引发频繁GC的东西（是，打印日志会导致频繁GC，打印了1w次必然出现GC，有意义吗？）才是罪魁祸首吧！

GC

* 写入几个字符1W次，mmap映射5M的时候，偶尔出现1次GC，普通写入文件必然出现GC，有时会出现多次GC
* 分析：同CPU