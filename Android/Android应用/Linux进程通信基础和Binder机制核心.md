##### Linux进程间通信

* 管道：有名、无名、（有无）亲缘关系、半双工-----------内核操作
* PV信号量：线程操作共享资源，用于进程内和多进程间-----------------内核操作
* socket----------内核操作
* 共享内存：通过内存映射到同一块物理区域，不需要任何读写操作，因为进程操作的虚拟地址空间是直接映射到物理页上的，但是需要考虑共享内存的安全，比如pv操作-----------内核操作
* 消息队列--------------内核操作

##### Linux中，需要实现进程间通信，是需要内核支持的

* 错误：文件可以实现夸进程
* 文件也是内核支持的

##### 共享内存效率高，只要涉及IPC，都采用这个方案

* 许多IPC方案很不适用，如socket、管道，如果实现Android的AMS这种场景，总觉得效率太低，而且太笨重了。

* 共享内存虽然减少了拷贝次数，但是，在生产上，每次自己通过共享内存实现IPC都比较麻烦或者很难管理，不利于维护
* 基于内存共享：实现高效的ipc，必然要基于内存共享的思想，即是物理内存和虚拟内存的共享的机制，这种机制下，不存在复制过程，是虚拟内存和物理内存映射关系，好比是直接操作的物理内存，多进程同时映射到一段物理内存，他们就能进行0次拷贝的通信
* binder通信机制复制了一次

##### 基于共享内存，开辟一个内核态的新IPC方法

* IPC要内核支持，那就基于内核的代码，再把新的IPC机制代码和Linux代码混在一起：错误，这样加大了内核编译复杂度
* 如果内核还是原来的Linux内核，利用Linux内核已有的功能，加上其他代码，不影响内核的情况下实现IPC

##### Linux系统中的module

* 为什么需要模块：Linux是单内核系统，所有功能内容放在一起，扩展性、维护性差，但是Linux有一套LKM的机制，允许动态扩展内核的功能，功能列表由Linux控制。这个动态的功能的实现就是模块
* 优点：内核更加紧凑、灵活、不需要每次重新编译内核
* 缺点：内核需要维护动态功能列表、模块出问题会导致一同崩溃、内核间可能有依赖的可能

##### Binder模块的程序是驱动程序

* 驱动程序一般是面向设备的，binder模块提供了IPC通信的接口，设备是整个终端，设备文件是/dev/binder

#### Binder是针对C/S模型

* 场景：进程A向进程B发送消息和数据，最简单的办法就是拿到进程B的一个对象，然后调用方法，传递参数过去，所以是C/S模型
* Linux用户态进程无法直接调用对方，因为进程在linux中，开辟的是虚拟内存空间，进程在用户态是无法感知的
* 进程间通信必须通过内核操作完成
* Binder机制是C进程向S进程发送消息和数据

#### Binder通信关注点

* C要S通信，就得知道S是谁，并且调用S进程的对象的方法，并将参数数据传输过去，C只关心调用哪个对象，以及哪个对象方法和传输哪些参数数据，其他的不关心，C进程这个操作不关心底层内核怎么做，因此这个步骤是属于用户空间态
* S进程不能直接告诉C进程说是它的服务器端，因为两个进程是不能直接通信的，他们都是独立的虚拟内存空间，相互隔离的，所以S只能先告诉一个更加具有系统级别的进程SM，告诉它我是一个远程服务器，我将来会提供什么服务。为什么是更系统级别的进程呢？因为普通进程相互隔离，如果没有一些特殊的系统功能，那么这个SM也就是中间的无用第三者，S甚至不能和它通信，它也就和C、S进程一样了。