#### 为什么学kotlin协程？

* Android kotlin语言的框架可能会涉及到使用协程的场景（偏三方应用）
* 学习协程这个思想

#### 需要学到什么程度

* 能满足基本使用
* 能使用协程搭建应用开发框架
* 能理解基本原理，不深入

###### 不推荐在编译负荷较大的场景使用kotlin语言开发

* Kotlin使用Kotlin compiler将源代码编译成class字节码，期间词法分析、语法分析等操作和Java compiler基本一致。如果使用kotlin，必然需要在编译环境中配备Kotlin compiler，这样加大了生产环境的复杂度和维护成本。

* Kotlin compiler的编译速度略低于Java compiler，这在百万级别的编译环境中，不管是clean编译还是增量编译，都有一定影响。Android10的源码在一般配置的环境中，可能会出现编译2h的整编时间！如果在这个基础上，哪怕是增加1%的编译负荷，谁也不知道总共会增加多少复核，编译时间可能是非线性的增加。

  <strong>因此，kotlin的协程和kotlin一样，都是非必要使用</strong>

###### kotlin中协程的思想

* 和线程的区别

  不像线程在内核态调度，更多体现在用户态，本质还是对java应用层线程的调度。更确切说，<strong>kotlin的协程是由编译器技术实现，不需要虚拟机和系统支持</strong>

* CPS的支持

  延续传递风格允许将的函数逻辑以闭包的形式返回给调用者，以前的编程风格中，通常是在第一步的回调方法中继续执行第二步，然后又在第二步的回调方法中执行第三步...等等，这样总是在恶劣的嵌套回调中。如：

  ```java
A{ a ->
      B(a){ b ->
        C(b){ c ->
              doSomething(c);
        	//....
      	}
  	}
  }
  ```
  
    在CPS中，回调的逻辑被封装成闭包返回了，调用者可以操作这个闭包，让其很直接明了给我们想要的回调结果，如：
  
  ```java
    a = A();
    b = B(a);
    c = C(b);
    doSomething(c);
  ```
  
  
* kotlin的协程更像是状态机

  就像是wifi状态机一样，有很多状态，协程主要就是挂起状态和继续执行状态。协程挂起主要是通过suspend关键字挂起，协程挂起并不阻塞线程，所以它只需要通过resume切换到运行态就好了。

* 协程是如何切换线程的

  很明显，通过Android的Handler，因为协程更像是编译器技术，没有改变Linux内核，所以只能通过Android SDK中的api实现线程切换，并且协程的源码中使用的就是handler.post和postDelay

###### kotlin协程的使用意义

* 协程的挂起操作不会阻塞线程，这样防止线程在阻塞和运行状态切换浪费大量开销（参看Future和Promise）。

* 轻量级，保证任务的多执行，提高线程的使用率，也无需考虑使用线程池的问题。

* CPS更加体现函数式编程的优点

* <strong>简化Callback回调、使方法更加单一，代码结构更加分明</strong>

  既然就是操作线程，那和普通多线程操作<strong>没有多大的区别，为啥还使用？直接使用rxjava也可以呀 </strong>

  通过协程的上下文、状态机、调度性，解决了<strong>callback回调复杂问题</strong>：

  如Rxjava请求网络后，只有在onSuccess或者onFail的类似回调方法中处理该次请求的结果，然后通知UI。看上去没有问题，但是1000个请求就有2000个回调要复写，还要持有UI的引用。

  是否有这样的功能：获取网络无非拿一个值，不要考虑线程切换、不要考虑线程并发和调度、不要考虑怎么写回调，拿到了就监听值的变化处理UI，没有拿到就不管，毕竟View更多是更具数据来驱动的。那么相当于就是一个被View监听的data变量，并且直接请求响应的接口，给这个data变量赋值就完了。等价于：

  ``` java
  var data = getData();
  ```

  getData包含了耗时的操作，不过是在IO线程完成的异步操作，getData什么时候完成并不关心，data值的变化的监听可以使用LiveData完成。

  这样一来，接口请求更加独立，没有了严重的回调甚至嵌套回调，更加适合多接口依赖上个接口的请求的接口的场景和多接口请求复用的场景（如：单repository多用）。